---
title: "Tidycensus Markdown"
author: "Samriddhi Khare"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
    code_download: true
  
---

## Introduction


This R Markdown document, titled "Tidycensus Markdown," authored by Samriddhi Khare, generates an HTML document with various sections containing code, explanations, and visualizations for analyzing Census data using the `tidycensus`, `dplyr`, and `ggplot2` packages in R. This document takes a close look at census tracts within the City of Philadelphia, with a focus on the Mt. Airy neighborhood, analyzing and visualizying its housing vacancy statistics. This code is built upon the classwork discussed [here](https://github.com/mafichman/musa_5080_2023/tree/main/Week_1) under the instruction of Professor Micheal Fichman. 
```{r setup, warning = FALSE, eval = FALSE}

library(tidyverse)
library(knitr)
library(kableExtra)
library(rmarkdown)
library(tidycensus)
library(sf)
library(dplyr)
library(ggplot2)
library(colorspace)
library(viridis)

knitr::opts_chunk$set(echo = TRUE)

census_api_key('bf2d507651b5a621dbadd44533fb4f3deaab26bf')
```
## Using TidyCensus

### Load census data dictionaries

Two sets of Census data dictionaries for the years 2020 and 2016 are loaded and stored in variables acs_variable_list.2020 and acs_variable_list.2016.

```{r load_variables, cache=TRUE}

acs_variable_list.2020 <- load_variables(2020, #year
                                         "acs5", #five year ACS estimates
                                         cache = TRUE)

acs_variable_list.2016 <- load_variables(2016, #year
                                         "acs5", #five year ACS estimates
                                         cache = TRUE)
```

### Creating a vector of census variables

After going through the data dictionaries, we can populate a vector of variable names we will send to the Census API. We call this list `acs_vars`. This vector includes only the varibles from the census that we will be using for further analysis. 

```{r acs_vars}
acs_vars <- c("B01001_001E", # ACS total Pop estimate
              "B25002_001E", # Estimate of total housing units
              "B25002_003E", # Number of vacant housing units
              "B19013_001E", # Median HH Income ($)
              "B02001_002E", # People describing themselves as "white alone"
              "B06009_006E") # Total graduate or professional degree
```

### Calling the Census API to get tract level data for 2020 for all of Philadelphia

Once we have decided and created the vecotr of relevant variables, we can call the data from the census using the `get_acs` function. 

```{r get_acs_2020, cache = TRUE, message = FALSE, warning = FALSE}
acsTractsPHL.2020 <- get_acs(geography = "tract",
                             year = 2020, 
                             variables = acs_vars, 
                             geometry = FALSE, 
                             state = "PA", 
                             county = "Philadelphia", 
                             output = "wide") 
```

## Using dplyr

### Mutating, selecting and renaming variables

This step involves the cleaning of data, renaming varibles from their ACS codes to layman's terms and performing basic calculations on the acquired variables to create new ones and storing them in new columns using the `select`, `rename`, and `mutate` functions in `dplyr`. 

```{r do_some_dplyr, cache = TRUE}
acsTractsPHL.2020 <- acsTractsPHL.2020 %>%
  dplyr::select (GEOID, NAME, all_of(acs_vars))

acsTractsPHL.2020 <- acsTractsPHL.2020 %>%
  rename (total_pop.2020 = B01001_001E,
          total_HU.2020 = B25002_001E,
          total_vacant.2020 = B25002_003E,
          med_HH_Income.2020 = B19013_001E,
          total_White.2020 = B02001_002E,
          total_GradDeg.2020 = B06009_006E)

acsTractsPHL.2020 <- acsTractsPHL.2020 %>%
  mutate(vacancyPct.2020 = (total_vacant.2020/total_HU.2020)*100,
         pctWhite.2020   = total_White.2020/total_pop.2020)
```

### Combine and re-run `tidycensus` and `dplyr` for 2016 data

```{r get_acs_2016, cache = TRUE, message = FALSE}
acsTractsPHL.2016 <- get_acs(geography = "tract",
                             year = 2016, 
                             variables = acs_vars,
                             geometry = FALSE,
                             state = "PA", 
                             county = "Philadelphia",
                             output = "wide") %>%
  dplyr::select (GEOID, NAME, all_of(acs_vars)) %>% 
  rename (total_pop.2016 = B01001_001E,
          total_HU.2016 = B25002_001E,
          total_vacant.2016 = B25002_003E,
          med_HH_Income.2016 = B19013_001E,
          total_White.2016 = B02001_002E,
          total_GradDeg.2016 = B06009_006E) %>%
  mutate(vacancyPct.2016 = total_vacant.2016/total_HU.2016,
         pctWhite.2016 = total_White.2016/total_pop.2016)
```

### Joining data

Join the data from 2016 to 2020, using a left join, using the GEOID as the index. 

```{r left_join_tracts, cache = TRUE}
allACS <- left_join(acsTractsPHL.2016, acsTractsPHL.2020,
                    by= c("GEOID"))
```

### Identifying Mount Airy

This identifying and stores the focused area of study - Mount Airy - as the `myTracts` vector, and creates a column in our joined dataframe, which also identifies which census tracts are within the study area. 

```{r myTracts, cache = TRUE}

myTracts <- c("42101023500", 
              "42101023600", 
              "42101023700", 
              "42101025300", 
              "42101025400",
              "42101025500", 
              "42101025600", 
              "42101038800")

allACS <- allACS %>%
  mutate(mtAiry = ifelse(GEOID %in% myTracts, "MT AIRY", "REST OF PHILADELPHIA"))
```

## Using ggplot 

(Homework here onwards)

This scatterplot of the number of vacant housing units in the City of Philadelphia in the year 2020 (Y axis) expressed as a function of vacant housing units in 2016 (X axis) tells us many interesting things about the city, as well as Mount Airy. 

1. The points seem equally distributed above and below the x=y line, with a small concentration of points occurring below the line, between 0-250 units. This means that a roughly equal number of census tracts have witnessed and increase and decrease in the number of vacant units.  

2. 4 out of the 6 tracts in Mt. Airy are located above the x=y line, indicating that most of the census tracts within the neighborhood witnessed an increase in the number of vacant units.  

```{r ggplot_point2, warning = FALSE, cache = TRUE, message = FALSE}
ggplot(allACS)+
  geom_point(aes(x = total_vacant.2016, 
                 y = total_vacant.2020,
                 color = mtAiry))+
  geom_smooth(aes(x = total_vacant.2016, 
                  y = total_vacant.2020), 
              method = "lm", se = FALSE, color = "Red")+
  colorspace::scale_color_discrete_sequential(palette = "plasma")+ theme_bw()+
  labs(
    title = "Number of Vacant Housing Units",
    subtitle = "",
    caption = "Data: US Census Bureau, ACS 5-year estimates",
    x="Vacant Units in 2016", 
    y="vacant Units in 2020",
    fill = "Neighborhood")
  
```

### Spatial Data

This map symbolizes the number of vacant housing units in 2016 as a percentage of total housing units. To get this result, we gather data using the `get_acs` function again, with the geometry being set to TRUE instead of false, giving us the spatial data as well as the numerical data. The associated dataframe is then turned to a simple features object, making it more workable in R. 

The vacancy percentage is calculated using the mutate function and is defined as = 100*(number of vacant HUs/total number of HUs)

We can see that within Mt. Airy, the vacancy remains relatively low when compared to other tracts, especially in Central Philadelphia. 

```{r spatial_tidycensus, warning=FALSE, cache=TRUE, include=FALSE}
acsTractsPHL.2016.sf <- get_acs(geography = "tract",
                             year = 2016, 
                             variables = acs_vars, 
                             geometry = TRUE, 
                             state = "PA", 
                             county = "Philadelphia", 
                             output = "wide") %>% 
  dplyr::select (GEOID, NAME, all_of(acs_vars)) %>%
  rename (total_pop.2016 = B01001_001E,
          total_HU.2016 = B25002_001E,
          total_vacant.2016 = B25002_003E,
          med_HH_Income.2016 = B19013_001E,
          total_White.2016 = B02001_002E,
          total_GradDeg.2016 = B06009_006E) %>%
  mutate(vacancyPct.2016 = (100*(total_vacant.2016/total_HU.2016))) %>%
  mutate(mtAiry = ifelse(GEOID %in% myTracts, "MT AIRY", "REST OF PHILADELPHIA")) %>%
  st_as_sf(crs = 4326) # Turn shp into sf object and project as WGS84
```

```{r ggplot_geom_sfa, warning=FALSE, cache=TRUE}
ggplot()+
  geom_sf(data = acsTractsPHL.2016.sf, aes(fill = vacancyPct.2016),
          color = "transparent")+
  geom_sf(data = acsTractsPHL.2016.sf %>%
            filter(mtAiry == "MT AIRY") %>%
            st_union(),
          color = "white",
          fill = "transparent")+
    viridis::scale_fill_viridis(option = "plasma")+ theme_bw() +
  labs(
    title = "Vacancy Percentage, 2016",
    subtitle = "",
    caption = "Data: US Census Bureau, ACS 5-year estimates",
    fill = "Percentage")
  
```

## Using kable

Here, the inference is that the average number of vacant housing units in the Mt. Airy census tracts is lower than the average number of vacant housing units elsewhere in Philadelphia in the year 2020. 

```{r summary_table_2a, cache = TRUE, message = FALSE, warning = FALSE}
summaryTableHW <- allACS %>%
 group_by(mtAiry) %>%
  summarize(mean_vacant_housing = mean(total_vacant.2020, na.rm = TRUE))

CN <- c("Neighborhood", "Mean Vacant Housing Units")

summary_kable <- summaryTableHW %>%
  kable(format = "html", align = "c",col.names = CN) %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)

summary_kable
            
```

## Conclusion

This markdown explores the various functionalities within R for data analytics. These analyses reveal insights into changes in vacant housing units over time and spatial variations within the city, which can be used to inform various planning processes. 

## Questions

Multiple times while knitting this markdown, I kept getting random errors about some functions not being found, despite all the relevant packages being loaded. I was able to fix this sometimes by changing the cache to TRUE instead of FALSE, and other times by adjusting the syntax within the function from "function()" to "package::function()". Why was this happening? And how can I prevent it? 